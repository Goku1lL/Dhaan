"""
Strategy Engine
Implements the actual trading logic for all defined strategies.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass

from ..core.logging_service import LoggingService
from .market_scanner import TradingOpportunity


@dataclass
class StrategySignal:
    """Represents a signal generated by a strategy."""
    signal_type: str  # 'BUY', 'SELL', 'SHORT', 'HOLD'
    confidence_score: float  # 0.0 to 1.0
    entry_price: float
    target_price: float
    stop_loss: float
    risk_reward_ratio: float
    indicators: Dict[str, Any]
    description: str


class StrategyEngine:
    """
    Strategy Engine
    Implements the actual trading logic for all defined strategies.
    """
    
    def __init__(self):
        """Initialize the strategy engine."""
        self.logger = LoggingService()
        
        # Strategy configurations
        self.strategies = {
            "MOMENTUM_BREAKOUT": self._momentum_breakout_strategy,
            "RSI_MEAN_REVERSION": self._rsi_mean_reversion_strategy,
            "ARBITRAGE_PAIRS": self._arbitrage_pairs_strategy,
            "GRID_TRADING_SYSTEM": self._grid_trading_strategy,
            "BOLLINGER_SQUEEZE": self._bollinger_squeeze_strategy,
            "GAP_FILL_STRATEGY": self._gap_fill_strategy,
            "VWAP_MA_MEAN_REVERSION": self._vwap_ma_mean_reversion_strategy,
            "TWO_CANDLE_OPTION_STRATEGY": self._two_candle_option_strategy
        }
        
        self.logger.info("Strategy Engine initialized with 8 strategies")
    
    def apply_strategy(self, strategy_name: str, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """
        Apply a specific strategy to stock data.
        
        Args:
            strategy_name: Name of the strategy to apply
            stock_data: Stock market data
            
        Returns:
            StrategySignal if conditions are met, None otherwise
        """
        try:
            if strategy_name not in self.strategies:
                self.logger.warning(f"Strategy {strategy_name} not found")
                return None
            
            # Apply the strategy
            strategy_func = self.strategies[strategy_name]
            signal = strategy_func(stock_data)
            
            if signal:
                self.logger.debug(f"Strategy {strategy_name} generated {signal.signal_type} signal for {stock_data['symbol']}")
            
            return signal
            
        except Exception as e:
            self.logger.log_error(e, {
                "operation": "apply_strategy",
                "strategy": strategy_name,
                "symbol": stock_data.get('symbol', 'UNKNOWN')
            })
            return None
    
    def _momentum_breakout_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Momentum Breakout Strategy implementation."""
        try:
            symbol = stock_data['symbol']
            current_price = stock_data['current_price']
            open_price = stock_data['open']
            volume = stock_data['volume']
            ohlcv = stock_data.get('ohlcv', [])
            
            if not ohlcv or len(ohlcv) < 20:
                return None
            
            # Convert OHLCV to DataFrame
            df = pd.DataFrame(ohlcv)
            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
            # Calculate indicators
            df['sma_20'] = df['close'].rolling(window=20).mean()
            df['volume_sma'] = df['volume'].rolling(window=20).mean()
            df['rsi'] = self._calculate_rsi(df['close'], 14)
            df['macd'], df['macd_signal'] = self._calculate_macd(df['close'])
            
            # Get latest values
            current_close = df['close'].iloc[-1]
            sma_20 = df['sma_20'].iloc[-1]
            volume_ratio = volume / df['volume_sma'].iloc[-1] if df['volume_sma'].iloc[-1] > 0 else 0
            rsi = df['rsi'].iloc[-1]
            macd = df['macd'].iloc[-1]
            macd_signal = df['macd_signal'].iloc[-1]
            
            # Breakout conditions
            price_above_sma = current_close > sma_20
            volume_confirmation = volume_ratio > 1.5
            rsi_momentum = 40 < rsi < 80
            macd_bullish = macd > macd_signal
            
            if (price_above_sma and volume_confirmation and rsi_momentum and macd_bullish):
                # Calculate entry, target, and stop loss
                entry_price = current_price
                target_price = entry_price * 1.06  # 6% target
                stop_loss = entry_price * 0.97     # 3% stop loss
                risk_reward = (target_price - entry_price) / (entry_price - stop_loss)
                
                confidence_score = min(0.9, 0.6 + (volume_ratio - 1.5) * 0.2 + (rsi - 40) * 0.01)
                
                return StrategySignal(
                    signal_type="BUY",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={
                        "sma_20": sma_20,
                        "volume_ratio": volume_ratio,
                        "rsi": rsi,
                        "macd": macd,
                        "macd_signal": macd_signal
                    },
                    description=f"Momentum breakout with volume confirmation. RSI: {rsi:.1f}, Volume: {volume_ratio:.1f}x"
                )
            
            return None
            
        except Exception as e:
            self.logger.log_error(e, {"operation": "momentum_breakout_strategy"})
            return None
    
    def _rsi_mean_reversion_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """RSI Mean Reversion Strategy implementation."""
        try:
            symbol = stock_data['symbol']
            current_price = stock_data['current_price']
            ohlcv = stock_data.get('ohlcv', [])
            
            if not ohlcv or len(ohlcv) < 14:
                return None
            
            # Convert OHLCV to DataFrame
            df = pd.DataFrame(ohlcv)
            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
            # Calculate RSI
            df['rsi'] = self._calculate_rsi(df['close'], 14)
            current_rsi = df['rsi'].iloc[-1]
            
            # Mean reversion conditions
            oversold = current_rsi < 30
            overbought = current_rsi > 70
            
            if oversold:
                # Buy signal on oversold
                entry_price = current_price
                target_price = entry_price * 1.035  # 3.5% target
                stop_loss = entry_price * 0.975     # 2.5% stop loss
                risk_reward = (target_price - entry_price) / (entry_price - stop_loss)
                
                confidence_score = min(0.85, 0.7 + (30 - current_rsi) * 0.01)
                
                return StrategySignal(
                    signal_type="BUY",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={"rsi": current_rsi},
                    description=f"RSI oversold reversal. RSI: {current_rsi:.1f}"
                )
            
            elif overbought:
                # Sell signal on overbought
                entry_price = current_price
                target_price = entry_price * 0.965  # 3.5% target
                stop_loss = entry_price * 1.025     # 2.5% stop loss
                risk_reward = (entry_price - target_price) / (stop_loss - entry_price)
                
                confidence_score = min(0.85, 0.7 + (current_rsi - 70) * 0.01)
                
                return StrategySignal(
                    signal_type="SELL",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={"rsi": current_rsi},
                    description=f"RSI overbought reversal. RSI: {current_rsi:.1f}"
                )
            
            return None
            
        except Exception as e:
            self.logger.log_error(e, {"operation": "rsi_mean_reversion_strategy"})
            return None
    
    def _gap_fill_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Common Gap Fill Strategy implementation."""
        try:
            symbol = stock_data['symbol']
            current_price = stock_data['current_price']
            open_price = stock_data['open']
            ohlcv = stock_data.get('ohlcv', [])
            
            if not ohlcv or len(ohlcv) < 3:
                return None
            
            # Convert OHLCV to DataFrame
            df = pd.DataFrame(ohlcv)
            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
            # Calculate gap
            prev_close = df['close'].iloc[-2] if len(df) > 1 else open_price
            gap_size = abs(open_price - prev_close) / prev_close * 100
            
            # Gap fill conditions (0.5% to 2% gap)
            valid_gap = 0.5 <= gap_size <= 2.0
            
            if valid_gap:
                # Determine gap direction
                gap_up = open_price > prev_close
                
                if gap_up:
                    # Gap up - look for fill (price coming down)
                    if current_price < open_price:
                        entry_price = current_price
                        target_price = prev_close  # Fill the gap
                        stop_loss = entry_price * 0.98  # 2% stop loss
                        risk_reward = (entry_price - target_price) / (entry_price - stop_loss)
                        
                        confidence_score = min(0.9, 0.7 + (gap_size - 0.5) * 0.1)
                        
                        return StrategySignal(
                            signal_type="SELL",
                            confidence_score=confidence_score,
                            entry_price=entry_price,
                            target_price=target_price,
                            stop_loss=stop_loss,
                            risk_reward_ratio=risk_reward,
                            indicators={"gap_size": gap_size, "gap_direction": "UP"},
                            description=f"Gap up fill opportunity. Gap: {gap_size:.1f}%"
                        )
                
                else:
                    # Gap down - look for fill (price coming up)
                    if current_price > open_price:
                        entry_price = current_price
                        target_price = prev_close  # Fill the gap
                        stop_loss = entry_price * 1.02  # 2% stop loss
                        risk_reward = (target_price - entry_price) / (stop_loss - entry_price)
                        
                        confidence_score = min(0.9, 0.7 + (gap_size - 0.5) * 0.1)
                        
                        return StrategySignal(
                            signal_type="BUY",
                            confidence_score=confidence_score,
                            entry_price=entry_price,
                            target_price=target_price,
                            stop_loss=stop_loss,
                            risk_reward_ratio=risk_reward,
                            indicators={"gap_size": gap_size, "gap_direction": "DOWN"},
                            description=f"Gap down fill opportunity. Gap: {gap_size:.1f}%"
                        )
            
            return None
            
        except Exception as e:
            self.logger.log_error(e, {"operation": "gap_fill_strategy"})
            return None
    
    def _vwap_ma_mean_reversion_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """VWAP + MA Mean Reversion Strategy implementation."""
        try:
            symbol = stock_data['symbol']
            current_price = stock_data['current_price']
            ohlcv = stock_data.get('ohlcv', [])
            
            if not ohlcv or len(ohlcv) < 20:
                return None
            
            # Convert OHLCV to DataFrame
            df = pd.DataFrame(ohlcv)
            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
            # Calculate VWAP and MA
            df['vwap'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
            df['sma_14'] = df['close'].rolling(window=14).mean()
            df['atr'] = self._calculate_atr(df, 14)
            
            current_vwap = df['vwap'].iloc[-1]
            current_sma = df['sma_14'].iloc[-1]
            current_atr = df['atr'].iloc[-1]
            
            # Mean reversion conditions
            price_below_vwap = current_price < current_vwap
            price_above_sma = current_price > current_sma
            atr_threshold = current_atr > 0
            
            if price_below_vwap and price_above_sma and atr_threshold:
                # Long signal
                entry_price = current_price
                target_price = entry_price + (3 * current_atr)  # 3x ATR target
                stop_loss = entry_price - current_atr            # 1x ATR stop loss
                risk_reward = (target_price - entry_price) / (entry_price - stop_loss)
                
                confidence_score = min(0.9, 0.7 + (current_vwap - current_price) / current_atr * 0.1)
                
                return StrategySignal(
                    signal_type="BUY",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={
                        "vwap": current_vwap,
                        "sma_14": current_sma,
                        "atr": current_atr
                    },
                    description=f"VWAP + MA mean reversion. Price below VWAP, above SMA. ATR: {current_atr:.2f}"
                )
            
            elif current_price > current_vwap and current_price < current_sma and atr_threshold:
                # Short signal
                entry_price = current_price
                target_price = entry_price - (3 * current_atr)  # 3x ATR target
                stop_loss = entry_price + current_atr            # 1x ATR stop loss
                risk_reward = (entry_price - target_price) / (stop_loss - entry_price)
                
                confidence_score = min(0.9, 0.7 + (current_price - current_vwap) / current_atr * 0.1)
                
                return StrategySignal(
                    signal_type="SHORT",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={
                        "vwap": current_vwap,
                        "sma_14": current_sma,
                        "atr": current_atr
                    },
                    description=f"VWAP + MA mean reversion. Price above VWAP, below SMA. ATR: {current_atr:.2f}"
                )
            
            return None
            
        except Exception as e:
            self.logger.log_error(e, {"operation": "vwap_ma_mean_reversion_strategy"})
            return None
    
    def _two_candle_option_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Enhanced 2-Candle Option Strategy implementation."""
        try:
            symbol = stock_data['symbol']
            current_price = stock_data['current_price']
            volume = stock_data['volume']
            ohlcv = stock_data.get('ohlcv', [])
            
            if not ohlcv or len(ohlcv) < 10:
                return None
            
            # Convert OHLCV to DataFrame
            df = pd.DataFrame(ohlcv)
            df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
            # Check for 2 consecutive high-volume candles
            if len(df) < 2:
                return None
            
            candle1_volume = df['volume'].iloc[-2]
            candle2_volume = df['volume'].iloc[-1]
            avg_volume = df['volume'].rolling(window=10).mean().iloc[-1]
            
            # Volume threshold check
            volume_threshold = 50000 if "BANKNIFTY" in symbol else 125000
            high_volume = candle1_volume > volume_threshold and candle2_volume > volume_threshold
            
            if not high_volume:
                return None
            
            # Calculate indicators
            df['vwap'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
            df['supertrend'] = self._calculate_supertrend(df, 10, 2)
            df['vwma'] = df['close'].rolling(window=10).mean()
            
            current_vwap = df['vwap'].iloc[-1]
            current_supertrend = df['supertrend'].iloc[-1]
            current_vwma = df['vwma'].iloc[-1]
            
            # Breakout conditions
            price_above_indicators = (current_price > current_vwap and 
                                    current_price > current_supertrend and 
                                    current_price > current_vwma)
            
            if price_above_indicators:
                # Long signal
                entry_price = current_price
                target_price = entry_price * 1.10  # 10% target
                stop_loss = entry_price * 0.95     # 5% stop loss
                risk_reward = (target_price - entry_price) / (entry_price - stop_loss)
                
                confidence_score = min(0.9, 0.7 + (candle2_volume / avg_volume - 1) * 0.1)
                
                return StrategySignal(
                    signal_type="BUY",
                    confidence_score=confidence_score,
                    entry_price=entry_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    risk_reward_ratio=risk_reward,
                    indicators={
                        "volume_ratio": candle2_volume / avg_volume,
                        "vwap": current_vwap,
                        "supertrend": current_supertrend,
                        "vwma": current_vwma
                    },
                    description=f"2-Candle breakout with volume confirmation. Volume: {candle2_volume/avg_volume:.1f}x"
                )
            
            return None
            
        except Exception as e:
            self.logger.log_error(e, {"operation": "two_candle_option_strategy"})
            return None
    
    # Placeholder implementations for other strategies
    def _arbitrage_pairs_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Statistical Arbitrage Strategy - placeholder implementation."""
        return None
    
    def _grid_trading_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Grid Trading Strategy - placeholder implementation."""
        return None
    
    def _bollinger_squeeze_strategy(self, stock_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Bollinger Band Squeeze Strategy - placeholder implementation."""
        return None
    
    # Technical indicator calculation methods
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """Calculate RSI indicator."""
        try:
            delta = prices.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            return rsi
        except:
            return pd.Series([np.nan] * len(prices))
    
    def _calculate_macd(self, prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series]:
        """Calculate MACD indicator."""
        try:
            ema_fast = prices.ewm(span=fast).mean()
            ema_slow = prices.ewm(span=slow).mean()
            macd = ema_fast - ema_slow
            macd_signal = macd.ewm(span=signal).mean()
            return macd, macd_signal
        except:
            return pd.Series([np.nan] * len(prices)), pd.Series([np.nan] * len(prices))
    
    def _calculate_atr(self, df: pd.DataFrame, period: int = 14) -> pd.Series:
        """Calculate Average True Range indicator."""
        try:
            high = df['high']
            low = df['low']
            close = df['close']
            
            tr1 = high - low
            tr2 = abs(high - close.shift())
            tr3 = abs(low - close.shift())
            
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            atr = tr.rolling(window=period).mean()
            return atr
        except:
            return pd.Series([np.nan] * len(df))
    
    def _calculate_supertrend(self, df: pd.DataFrame, period: int = 10, multiplier: float = 2.0) -> pd.Series:
        """Calculate SuperTrend indicator - simplified implementation."""
        try:
            # Simplified SuperTrend calculation
            atr = self._calculate_atr(df, period)
            basic_upper = (df['high'] + df['low']) / 2 + (multiplier * atr)
            basic_lower = (df['high'] + df['low']) / 2 - (multiplier * atr)
            
            # This is a simplified version - full SuperTrend is more complex
            supertrend = basic_lower  # Simplified
            return supertrend
        except:
            return pd.Series([np.nan] * len(df)) 